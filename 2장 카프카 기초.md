## 2장 카프카 기초

#### 주요 구성 요소

- 브로커 : 데이터를 수신, 전달하는 서비스
- 메시지 : 데이터의 최소 단위,  Key, Value를 가짐
- 프로듀서 : 데이터의 생산자, 브로커에 메시지를 보내는 애플리케이션
- 컨슈머 : 브로커에서 메시지를 취득하는 애플리케이션
- 토픽 : 메시지를 종류별로 관리하는 스토리지



 #### Pull & Push 형

프로듀서 -> 브로커의 메시지 송신은 프로듀서가 주체가 되어 브로커에 전송하는 **Push 형**

브로커 -> 컨슈머로의 메시지 송신 요청은 컨슈머에서 요청을 계기로 메시지가 송신된다. 따라서 브로커에서 볼때 **Pull 형**



#### 분산 메시징을 위한 구조

**파티션**

-  토픽에 대한 대량의 메시지 입출력을 지원하기 위해 **브로커상의 데이터를 읽고 쓰는 것**은 **파티션**이라는 단위로 분할
- 프로듀서에서의 **메시지 수신**, 컨슈머로의 **배달**을 **분산**해서 실시함으로써 **대규모 데이터 수신과 전달**을 지원
- 파티션은 브로커에서 구현, 프로듀서/컨슈머는 토픽만 지정하고 파티션을 의식할 필요가 없음

**컨슈머 그룹**

- 단일 애플리케이션 안에서 여러 컨슈머가 단일 토픽이나 여러 파티션에서 메시지를 취득하는 방법

**오프셋**

- 수신한 메시지에는 각각 **일련번호**가 부여되어 있어 **파티션 단위로 메시지 위치를 나타내는** 관리 정보
- 이를 통해 컨슈머가 취득하는 메시지의 범위 및 재시도를 제어
  - Log-End-Offset(LEO) : 파티션의 데이터의 끝을 나타냄
  - Current Offset : 컨슈머가 어디까지 메시지를 읽었는가를 나타냄
  - Commit Offset : 컨슈머가 어디까지 커밋했는지를 나타냄



**메시지 송수신**

- 프로듀서의 메시지 송신 : 디폴트로는 한번에 하나의 메시지를 송신하지만 **처리량을 향상**을 위해 작은 여러메시지나 큰 하나의 메시지를 모아서 **배치 송신**할 수 있음.
- 컨슈머의 메시지 취둑 : 컨슈머는 Current Offset으로 나타나는 위치에서 마지막으로 취득한 메시지까지 모아서 요청 및 취득을 실시

**컨슈머의 롤백**

OffSet Commit의 구조를 이용해 컨슈머 처리 실패, 고장시 롤백 메시지 재취득을 실현.

**메세지 전송 시 파티셔닝**

- Key 의 해시 값을 사용한 송신
- 라운드 로빈에 의한 송신

**복제 구조**

서버가 고장 났을 때에 수신한 메시지를 잃지 않기 위해 복제 구조를 갖추고 있다.



**정리**

- 스케일 아웃 구성

  메시지를 중계하는 브로커를 여러 대 구성할 수 있으며, 브로커 수를 증가함으로써 클러스터 전체의 처리량을 증가할 수 있음.

- 데이터의 디스크 영속화

  브로커에서 수신한 메시지는 디스크에 기록되어 영속화 됨.

- 연계할 수 있는 제품 존재

- 메시지의 도달 보증

  Ack와 Offset Commit 방식으로 메시지가 제대로 송수신되었음을 확인하고 실패 시 재시도를 허용함.
