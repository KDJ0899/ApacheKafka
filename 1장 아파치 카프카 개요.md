## 1장 아파치 카프카 개요

아파치 카프카는 여러 대의 분산 서버에서 대량의 데이터를 처리하는 **분산 메시징 시스템**이다.

여러 시스템과 장치를 연결하는 중요한 역할



카프카는 대량의 데이터를 **높은 처리량**과 **실시간**으로 취급하기 위한 제품

- 확장성 : 여러 서버로 '확장 구성'할 수 있기 때문에 데이터 양에 따라 시스템 확장이 가능
- 영속성 : 수신한 데이터를 '디스크에 유지'할 수 있기 때문에 언제라도 데이터를 읽을 수 있다
- 유연성 : '연계할 수 있는 제품이 많기' 때문에 제품이나 시스템을 연결하는 허브 역할을 한다.
- 신뢰성 : '메세지 전달 보증'을 하므로 데이터 분실을 걱정하지 않아도 된다.

<br>

### 카프카의 특징

### 1. 메시징 모델과 스케일 아웃

   카프카 에서는 메시징 모델을 채용, 기존의 **큐잉 모델**과 **Publish / Subscribe(펍/섭) 메세징 모델**의 특징을 겸비한 형태로 구현.

   - **큐잉 모델**

     브로커안에 큐를 준비해, 프로듀서에서의 메시지가 큐에 담기고, 컨슈머가 큐에서 메세지를 추출.

     하나의 큐에 대해 여러 컨슈머가 접근 가능.

   - **펍/섭 메시징 모델**

     프로듀서 - Publisher, 컨슈머 -  Subscriber로 정의

     퍼블리셔는 누가 그 메시지를 수신하는지 알 수 없고 브로커에 있는 토픽이라 불리는 카테고리 안에 메시지를 등록.

     구독자는 여러 개 존재하는 토픽중 하나를 선택하여 메시지를 받는다.

     큐잉 모델과는 달리 같은 토픽을 구독하는 여러 구독자에게 동일한 메시지가 전달됨

   카프카에서는 큐잉 모델에서 실현한 **여러 컨슈머가 분산 처리로 메시지를 소비**하는 모델과

   펍/섭 메시징 모델에서 실현한 **여러 구독자에게 동일한 메시지를 전달**하고, **토픽 기반으로 전달 내용을 변경**하는 모델로 구현.



### 2. 디스크로의 데이터 영속화

   카프카의 메시지 영속화는 메모리가 아닌 디스크에서 이루어짐, 따라서 디스크에 영속화 함에도 불구하고 높은 처리량을 제공.

   속속 들어오는 데이터를 받아들이면서 한 묶음으로 장기 보존을 목적으로 영속화할 수 있기 때문에 카프카를 **스토리지 시스템**으로도 간주 할 수 있음.



### 3. 이해하기 쉬운  API 제공



### 4. 전달 보증

   Exactly Once 실현 - 메시지를 정상적으로 받지 못한 경우 재전송하고 메시지가 중복 되지 않도록하는 전달 보증 수준

   - 상류 시스템에서 중복 메시지를 제거하는 방법
   
    ![1](https://user-images.githubusercontent.com/41800328/123653393-0ced2a80-d868-11eb-8080-044774df6259.JPG)

   - 하류 시스템에서 트랜잭션 중단을 해석하는 모습
   
     ![1](https://user-images.githubusercontent.com/41800328/123653562-373ee800-d868-11eb-8ad3-b0c8809d412e.JPG)



  브로카와 컨슈머 간 교환에 있어서는 컨슈머에 대해 트랜잭션의 범위를 해석하고, **트랜잭션 중단 시 중단까지의 처리를 파기하는 기능이 있다.**

  카프카 단독으로 전달보증을 실현하긴 어려움

